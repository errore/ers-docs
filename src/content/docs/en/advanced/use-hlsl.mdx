---
title: Using HLSL in Forward Rendering Pipeline
---

import { LinkCard } from '@astrojs/starlight/components';
import { FileTree } from '@astrojs/starlight/components';


## Using the HLSL Plugin

It is strongly recommended to use the `HLSL Material` plugin for writing HLSL code.

Alternatively, you can directly use the `Custom` node to write HLSL code.

<LinkCard
    title="Skip this section without using plugins"
    href="#using-ers-in-hlsl"
/>

### Installing the HLSL Material Plugin

:::tip
This plugin provides the functionality of **automatically generating function nodes** from HLSL functions, simplifying the process of using HLSL code in materials.
:::

The original plugin cannot be compiled properly in UE 5.6+ versions, and the author may have stopped maintaining it. I provide a fixed version that you can download from the Github repository below, then unzip to the Plugins directory:

<LinkCard
    title="HLSL Material Plugin"
    href="https://github.com/errore/HLSLMaterial"
    description="UE 5.6+ Fixed Version"
    target="_blank"
/>

After installation, your project structure should look like this:

<FileTree>

- YourProjectRoot
    - ...
    - Plugins
        - **HLSLMaterial-master**
            - HLSLMaterial.uplugin
            - ...
    - ...

</FileTree>

You can also directly clone the repository to the project's Plugins directory using the following command:

```
git clone https://github.com/errore/HLSLMaterial.git
```

### Using HLSL to Write Nodes

After installation, you can follow the original plugin's instructions to write and use HLSL code:

```hlsl ins={"Add your own shading logic":9-11}
// @param BaseColor Material color
// @param Color Render result
void SampleNode(float3 BaseColor,
	out float3 Color,
	FMaterialPixelParameters Parameters)
{
    float3 V = normalize(Parameters.CameraVector);
    float3 N = Parameters.WorldNormal;

    ...

    Color = BaseColor * ...;
}
```
This will generate a custom function node named `SampleNode` that takes `BaseColor` and outputs `Color` color.

## Using ERS in HLSL

ERS defines a custom light data structure to store custom light data.

```hlsl
// CustomLightData.ush
struct FCustomLight
{
    float3 L;               // Light direction
    float3 Color;           // Light color
    float Attenuation;      // Light attenuation
    float Shadow;           // Light shadow
    float SpecularScale;    // Specular reflection
    bool bIsRect;           // Is it a rectangular light
};
```
ERS injects the LightPacket structure to store custom light data.

```
// CustomLightData.ush
struct FCustomLightPacket
{
	uint NumLights; // Number of lights in the current block
	bool bHasDirectionalLight; // Is directional light enabled
	FCustomLight DirectionalLight; // Directional light
	FCustomLight Lights[NUM_CUSTOM_LIGHTS]; // Other lights
	float SSAO; // SSAO

	float3 BakedDiffuseLighting; // Baked global lighting diffuse
	float3 BakedSubsurfaceLighting; // Baked global lighting subsurface
	float3 Reflections; // Baked global lighting reflections
};
```
You can access the above custom light data using `CustomLightPack` in blueprint nodes.

In custom HLSL nodes, you can use the following code to calculate custom lights.

```hlsl ins={"Add your own shading logic":3-5} ins={"Add your own shading logic":11-13}
FCustomLight DirLight = CustomLightPack.DirectionalLight;


float Shadow = DirLight.Shadow;
...

for (int i = 0; i < CustomLightPack.NumLights; i++)
{
    FCustomLight Light = CustomLightPack.Lights[i];


    float NoL = dot(Light.L, N);
    ...

}
```
